<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat Ng∆∞·ªùi D√πng</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
    <style>
        body {
            background-color: #f8f9fa;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; /* Lo·∫°i b·ªè margin m·∫∑c ƒë·ªãnh c·ªßa body */
        }
        .container {
            margin-top: 30px;
            max-width: 100%; /* T·∫≠n d·ª•ng chi·ªÅu r·ªông t·ªëi ƒëa */
            padding-right: 220px; /* ƒê·ªÉ l·∫°i kho·∫£ng tr·ªëng cho √¥ danh s√°ch ng∆∞·ªùi d√πng */
        }
        .sidebar, .main-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            height: calc(100vh - 60px);
        }
        .sidebar {
            border-left: 5px solid #007bff;
        }
        .main-content {
            border-left: 5px solid #28a745;
            padding: 0;
        }
        .user-list-sidebar {
            background: white;
            padding: 15px;
            border-left: 5px solid #007bff;
            height: calc(100vh - 60px);
            overflow-y: auto;
            position: fixed;
            right: 0;
            top: 30px; /* ƒê·∫£m b·∫£o cƒÉn ƒë·∫ßu trang c√πng container */
            width: 200px;
            border-radius: 15px 0 0 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            z-index: 1000; /* ƒê·∫£m b·∫£o n·∫±m tr√™n c√°c ph·∫ßn kh√°c */
        }
        .scrollable-content {
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            padding: 25px;
            position: relative;
        }
        .chat-area {
            height: calc(100vh - 200px);
            overflow-y: auto;
            padding: 15px;
            background-color: #f1f1f1;
            border-radius: 10px;
        }
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .message.sent {
            background-color: #007bff;
            color: white;
            text-align: right;
        }
        .message.received {
            background-color: #e9ecef;
            text-align: left;
        }
        .btn-custom {
            transition: all 0.3s;
        }
        .btn-custom:hover {
            transform: translateY(-2px);
        }
        .user-list-item:hover {
            background-color: #f1f1f1;
            cursor: pointer;
        }
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
        }
        .crypto-area {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 10px;
        }
        .key-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 12px;
        }
        .key-display .btn-copy-aes {
            height: 38px;
            width: 70px;
            font-size: 14px;
        }
        #loadingOverlay {
          position: absolute;
          top: 10px;
          right: 20px;
          z-index: 1001;
        }
        .d-none {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row g-4">
            <div class="col-lg-4 col-md-5 sidebar">
                <div id="userArea">
                    <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi JavaScript -->
                </div>
            </div>
            <div class="col-lg-8 col-md-7 main-content">
                <div class="scrollable-content">
                    <h2 class="mb-4 text-success">Chat Ng∆∞·ªùi D√πng</h2>

                    <div id="loadingOverlay" class="d-none mt-2 text-center">
                      <div class="spinner-border text-primary" role="status">
                          <span class="visually-hidden">Loading...</span>
                      </div>
                      <p class="mt-1">ƒêang m√£ h√≥a ƒë·ªÉ g·ª≠i...</p>
                    </div>

                    <div id="chatArea" class="chat-area"></div>
                    <div class="input-group mt-3">
                      <input type="text" id="messageInput" class="form-control" placeholder="Nh·∫≠p tin nh·∫Øn..." />
                      <button class="btn btn-primary btn-custom" onclick="sendMessage()">G·ª≠i</button>
                      <button class="btn btn-success btn-custom" onclick="sendEncryptedMessage()">G·ª≠i c√≥ m√£ h√≥a</button>
                  </div>
                </div>
            </div>
        </div>
    </div>
    <!-- √î d·ªçc nh·ªè b√™n ph·∫£i cho danh s√°ch ng∆∞·ªùi d√πng - ƒë·∫∑t ngo√†i container -->
    <div class="user-list-sidebar">
        <h3 class="text-success">Danh s√°ch Ng∆∞·ªùi D√πng</h3>
        <ul id="userList" class="list-group"></ul>
    </div>
    <div class="toast-container">
        <div id="toastMessage" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-autohide="true" data-bs-delay="3000">
            <div class="toast-header">
                <strong class="me-auto">Th√¥ng b√°o</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const SERVER_IP = "atbm.onrender.com";
        const TOKEN_KEY = "authToken";
        let currentUsername = localStorage.getItem("currentUsername") || null; // L·∫•y username t·ª´ localStorage khi kh·ªüi t·∫°o
        let socket = null;
        let savedPublicKey = null;
        let savedAESKey = null;

        function showToast(message, type) {
            const toast = document.getElementById("toastMessage");
            const toastBody = toast.querySelector(".toast-body");
            toastBody.textContent = message;
            toast.className = `toast ${type === "success" ? "bg-success text-white" : "bg-danger text-white"}`;
            const bsToast = new bootstrap.Toast(toast);
            bsToast.show();
        }

        function checkLoginStatus() {
            const token = localStorage.getItem(TOKEN_KEY);
            const userArea = document.getElementById("userArea");
            if (token) {
                currentUsername = localStorage.getItem("currentUsername") || currentUsername || "Ng∆∞·ªùi d√πng"; // ƒê·ªçc l·∫°i t·ª´ localStorage
                userArea.innerHTML = `
                    <div class="user-area">
                        <h3 class="text-primary">Ch√†o, ${currentUsername}</h3>
                        <button class="btn btn-danger w-100 btn-custom" onclick="logout()">ƒêƒÉng xu·∫•t</button>
                        <div class="crypto-area">
                            <h5 class="text-info">M√£ h√≥a RSA</h5>
                            <button class="btn btn-primary btn-custom w-100 mb-2" onclick="generateRSAKeys()">T·ª± sinh c·∫∑p kh√≥a RSA</button>
                            <div class="input-group mb-2">
                                <input type="text" id="rsaPublicKeyInput" class="form-control key-display" placeholder="Nh·∫≠p kh√≥a c√¥ng khai RSA..." />
                                <button class="btn btn-outline-secondary" onclick="savePublicKey()">L∆∞u</button>
                                <button class="btn btn-outline-secondary" onclick="navigator.clipboard.writeText(document.getElementById('rsaPublicKeyInput').value)">Copy</button>
                            </div>
                            <button class="btn btn-success btn-custom w-100 mb-2" onclick="generateAESKey()">T·ª± sinh kh√≥a AES</button>
                            <div id="aesKey" class="key-display mb-2"></div>
                            <button class="btn btn-warning btn-custom w-100 mb-2" onclick="encryptAESKey()">M√£ h√≥a kh√≥a AES</button>
                            <div class="input-group mb-2">
                                <input type="text" id="encryptedAESInput" class="form-control" placeholder="Nh·∫≠p chu·ªói AES ƒë√£ m√£ h√≥a..." />
                                <button class="btn btn-info btn-custom" onclick="decryptAESKey()">Gi·∫£i m√£ AES</button>
                            </div>
                            <div class="input-group mb-2">
                                <input type="text" id="aesKeyInput" class="form-control" placeholder="Nh·∫≠p kh√≥a AES..." />
                                <button class="btn btn-outline-primary btn-custom" onclick="saveAESKey()">L∆∞u</button>
                            </div>
                            <div id="aesKeyStatus" class="text-muted small mt-1">Kh√¥ng c√≥ key m√£ AES</div>
                        </div>
                    </div>`;
                loadUserList();
                connectWebSocket();
            } else {
                userArea.innerHTML = `
                    <h3 class="text-primary">ƒêƒÉng nh·∫≠p</h3>
                    <input type="text" id="username" class="form-control mb-3" placeholder="Username">
                    <input type="password" id="password" class="form-control mb-3" placeholder="Password">
                    <button class="btn btn-primary w-100 btn-custom" onclick="login()">ƒêƒÉng nh·∫≠p</button>
                    <p id="loginMessage" class="mt-2"></p>
                    <hr />
                    <h3 class="text-success">ƒêƒÉng k√Ω</h3>
                    <input type="text" id="regUsername" class="form-control mb-3" placeholder="Username">
                    <input type="password" id="regPassword" class="form-control mb-3" placeholder="Password">
                    <button class="btn btn-success w-100 btn-custom" onclick="register()">ƒêƒÉng k√Ω</button>
                    <p id="registerMessage" class="mt-2"></p>`;
            }
        }

        async function login() {
            const username = document.getElementById("username").value.trim();
            const password = document.getElementById("password").value.trim();
            const loginMessage = document.getElementById("loginMessage");

            if (!username || !password) {
                loginMessage.className = "text-danger";
                loginMessage.innerText = "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin!";
                return;
            }

            try {
                const response = await fetch("/user/login/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username, password }),
                });
                const data = await response.json();

                if (data.token) {
                    localStorage.setItem(TOKEN_KEY, data.token);
                    currentUsername = username;
                    checkLoginStatus();
                    showToast("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!", "success");
                } else {
                    loginMessage.className = "text-danger";
                    loginMessage.innerText = data.error || "Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u";
                }
            } catch (error) {
                loginMessage.className = "text-danger";
                loginMessage.innerText = "L·ªói k·∫øt n·ªëi!";
            }
        }

        async function register() {
            const username = document.getElementById("regUsername").value.trim();
            const password = document.getElementById("regPassword").value.trim();
            const registerMessage = document.getElementById("registerMessage");

            if (!username || !password) {
                registerMessage.className = "text-danger";
                registerMessage.innerText = "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin!";
                return;
            }

            try {
                const response = await fetch("/user/register/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username, password }),
                });
                const data = await response.json();

                if (data.token) {
                    localStorage.setItem(TOKEN_KEY, data.token);
                    currentUsername = username;
                    checkLoginStatus();
                    showToast("‚úÖ ƒêƒÉng k√Ω th√†nh c√¥ng!", "success");
                } else {
                    registerMessage.className = "text-danger";
                    registerMessage.innerText = data.error || "L·ªói ƒëƒÉng k√Ω! Vui l√≤ng th·ª≠ l·∫°i.";
                }
            } catch (error) {
                registerMessage.className = "text-danger";
                registerMessage.innerText = "L·ªói k·∫øt n·ªëi!";
            }
        }

        async function logout() {
            const token = localStorage.getItem(TOKEN_KEY);
            if (!token) {
                showToast("‚ùå B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!", "error");
                return;
            }

            try {
                const response = await fetch("/user/logout/", {
                    method: "POST",
                    headers: { "Authorization": "Token " + token },
                });

                if (response.status === 200) {
                    localStorage.removeItem(TOKEN_KEY);
                    currentUsername = null;
                    if (socket) socket.close();
                    checkLoginStatus();
                    document.getElementById("chatArea").innerHTML = "";
                    showToast("‚úÖ ƒêƒÉng xu·∫•t th√†nh c√¥ng!", "success");
                } else {
                    showToast("‚ùå L·ªói khi ƒëƒÉng xu·∫•t!", "error");
                }
            } catch (error) {
                showToast("üö® L·ªói k·∫øt n·ªëi!", "error");
            }
        }

        async function loadUserList() {
            const token = localStorage.getItem(TOKEN_KEY);
            try {
                const response = await fetch("/user/list/", {
                    method: "GET",
                    headers: { "Authorization": "Token " + token },
                });
                const users = await response.json();
                const userList = document.getElementById("userList");
                userList.innerHTML = "";
                users.forEach(user => {
                    if (user.username !== currentUsername) {
                        const li = document.createElement("li");
                        li.className = "list-group-item user-list-item";
                        li.innerText = user.username;
                        userList.appendChild(li);
                    }
                });
            } catch (error) {
                showToast("‚ùå L·ªói t·∫£i danh s√°ch ng∆∞·ªùi d√πng!", "error");
            }
        }

        function connectWebSocket() {
            //socket = new WebSocket(`ws://${window.location.host}/ws/socket-server/`);
            //socket = new WebSocket(`ws://${SERVER_IP}:8000/ws/socket-server/`);
            socket = new WebSocket(`wss://atbm.onrender.com/ws/socket-server/`);

            socket.onopen = () => {
                console.log("WebSocket connected");
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === "chat") {
                    displayMessage(data.message, data.username === currentUsername);
                }
            };

            socket.onclose = () => {
                console.log("WebSocket disconnected");
            };
        }

        function sendMessage() {
            const messageInput = document.getElementById("messageInput");
            const message = messageInput.value.trim();

            if (!message) {
                showToast("‚ùå Vui l√≤ng nh·∫≠p tin nh·∫Øn!", "error");
                return;
            }

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showToast("‚ùå Ch∆∞a k·∫øt n·ªëi WebSocket!", "error");
                return;
            }

            const payload = {
                message: `${currentUsername}: ${message}`,
                username: currentUsername
            };
            socket.send(JSON.stringify(payload));
            messageInput.value = "";
        }

        async function displayMessage(message, isSent) {
          const chatArea = document.getElementById("chatArea");
          const div = document.createElement("div");
          div.className = `message ${isSent ? "sent" : "received"}`;
      
          if (message.includes("[ENCRYPTED]") && savedAESKey) {
              // Tr√≠ch xu·∫•t ph·∫ßn m√£ h√≥a t·ª´ tin nh·∫Øn
              const encryptedPart = message.split("[ENCRYPTED]")[1].trim();
              div.style.backgroundColor = isSent ? "#28a745" : "#d4edda"; // M√†u cho tin nh·∫Øn m√£ h√≥a
              div.title = "Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c m√£ h√≥a";
      
              // Gi·∫£i m√£ t·ª± ƒë·ªông
              const decryptedMessage = await decryptMessage(encryptedPart);
              div.innerText = decryptedMessage;
      
              if (decryptedMessage.includes("Kh√¥ng th·ªÉ gi·∫£i m√£") || decryptedMessage.includes("L·ªói k·∫øt n·ªëi")) {
                  div.style.backgroundColor = "#ffc107"; // M√†u v√†ng n·∫øu kh√¥ng gi·∫£i m√£ ƒë∆∞·ª£c
                  div.title = "Kh√¥ng th·ªÉ gi·∫£i m√£ v·ªõi kh√≥a AES hi·ªán t·∫°i";
              }
          } else if (message.includes("[ENCRYPTED]") && !savedAESKey) {
              div.innerText = message;
              div.style.backgroundColor = "#ffc107"; // M√†u v√†ng n·∫øu kh√¥ng c√≥ kh√≥a
              div.title = "Kh√¥ng c√≥ kh√≥a AES ƒë·ªÉ gi·∫£i m√£";
          } else {
              div.innerText = message;
          }
      
          chatArea.appendChild(div);
          chatArea.scrollTop = chatArea.scrollHeight;
        }

        async function generateRSAKeys() {
            const token = localStorage.getItem(TOKEN_KEY);
            try {
                const response = await fetch("/chat/generate-rsa/", {
                    method: "GET",
                    headers: { "Authorization": "Token " + token },
                });
                const data = await response.json();
                if (data.public_key) {
                    document.getElementById("rsaPublicKeyInput").value = data.public_key;
                    showToast("‚úÖ " + data.message, "success");
                } else {
                    showToast("‚ùå " + data.error, "error");
                }
            } catch (error) {
                showToast("‚ùå L·ªói k·∫øt n·ªëi!", "error");
            }
        }

        function savePublicKey() {
            const publicKey = document.getElementById("rsaPublicKeyInput").value.trim();
            if (publicKey) {
                savedPublicKey = publicKey;
                showToast("‚úÖ ƒê√£ l∆∞u kh√≥a c√¥ng khai!", "success");
            } else {
                showToast("‚ùå Ch∆∞a c√≥ kh√≥a c√¥ng khai ƒë·ªÉ l∆∞u!", "error");
            }
        }

        async function generateAESKey() {
            const token = localStorage.getItem(TOKEN_KEY);
            try {
                const response = await fetch("/chat/generate-aes/", {
                    method: "GET",
                    headers: { "Authorization": "Token " + token },
                });
                const data = await response.json();
                if (data.aes_key) {
                    document.getElementById("aesKey").innerHTML = `
                        <div class="input-group mb-2">
                            <input type="text" class="form-control key-display" value="Kh√≥a AES: ${data.aes_key}" readonly />
                            <button class="btn btn-outline-secondary" onclick="navigator.clipboard.writeText('${data.aes_key}')">Copy</button>
                        </div>`;
                    document.getElementById("aesKeyInput").value = data.aes_key; 
                    savedAESKey = data.aes_key; 
                    aesKeyStatus.textContent = "C√≥ key m√£ AES"; 
                    aesKeyStatus.className = "text-success small mt-1"; 
                    showToast("‚úÖ " + data.message, "success");
                } else {
                    showToast("‚ùå " + data.error, "error");
                }
            } catch (error) {
                showToast("‚ùå L·ªói k·∫øt n·ªëi!", "error");
            }
        }

        async function encryptAESKey() {
            const token = localStorage.getItem(TOKEN_KEY);
            if (!savedPublicKey) {
                showToast("‚ùå Vui l√≤ng l∆∞u kh√≥a c√¥ng khai tr∆∞·ªõc!", "error");
                return;
            }
            const payload = { "public_key": savedPublicKey };
            console.log("JSON g·ª≠i ƒëi:", JSON.stringify(payload));
            try {
                const response = await fetch("/chat/encrypt-aes/", {
                    method: "POST",
                    headers: { 
                        "Authorization": "Token " + token,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                console.log("Response t·ª´ server:", data);
                if (response.ok && data.encrypted_aes_key) {
                    document.getElementById("aesKey").innerHTML = `
                        <div class="input-group mb-2">
                            <input type="text" class="form-control key-display" value="Kh√≥a AES m√£ h√≥a: ${data.encrypted_aes_key}" readonly />
                            <button class="btn btn-outline-secondary" onclick="navigator.clipboard.writeText('${data.encrypted_aes_key}')">Copy</button>
                        </div>`;
                    showToast("‚úÖ " + data.message, "success");
                } else {
                    showToast("‚ùå " + (data.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server"), "error");
                    console.log("L·ªói t·ª´ server:", data);
                }
            } catch (error) {
                showToast("‚ùå L·ªói k·∫øt n·ªëi!", "error");
                console.error("L·ªói chi ti·∫øt:", error);
            }
        }

        async function decryptAESKey() {
            const token = localStorage.getItem(TOKEN_KEY);
            const encryptedAES = document.getElementById("encryptedAESInput").value.trim();
            if (!encryptedAES) {
                showToast("‚ùå Vui l√≤ng nh·∫≠p chu·ªói AES ƒë√£ m√£ h√≥a!", "error");
                return;
            }

            const payload = { "encrypted_aes": encryptedAES };
            console.log("JSON g·ª≠i ƒëi:", JSON.stringify(payload));
            try {
                const response = await fetch("/chat/decrypt-aes/", {
                    method: "POST",
                    headers: { 
                        "Authorization": "Token " + token,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                console.log("Response t·ª´ server:", data);
                if (response.ok && data.decrypted_aes_key) {
                    document.getElementById("aesKey").innerHTML = `
                        <div class="input-group mb-2">
                            <input type="text" class="form-control key-display" value="Kh√≥a AES gi·∫£i m√£: ${data.decrypted_aes_key}" readonly />
                            <button class="btn btn-outline-secondary" onclick="navigator.clipboard.writeText('${data.decrypted_aes_key}')">Copy</button>
                        </div>`;
                    showToast("‚úÖ " + data.message, "success");
                } else {
                    showToast("‚ùå " + (data.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ server"), "error");
                    console.log("L·ªói t·ª´ server:", data);
                }
            } catch (error) {
                showToast("‚ùå L·ªói k·∫øt n·ªëi!", "error");
                console.error("L·ªói chi ti·∫øt:", error);
            }
        }
      // H√†m g·ª≠i tin nh·∫Øn m√£ h√≥a v·ªõi loading
      async function sendEncryptedMessage() {
        const messageInput = document.getElementById("messageInput");
        const message = messageInput.value.trim();

        if (!message) {
            showToast("‚ùå Vui l√≤ng nh·∫≠p tin nh·∫Øn!", "error");
            return;
        }

        if (!savedAESKey) {
            showToast("‚ùå Vui l√≤ng l∆∞u kh√≥a AES tr∆∞·ªõc!", "error");
            return;
        }

        if (!socket || socket.readyState !== WebSocket.OPEN) {
            showToast("‚ùå Ch∆∞a k·∫øt n·ªëi WebSocket!", "error");
            return;
        }

        showLoading(); // Hi·ªÉn th·ªã loading

        try {
            const token = localStorage.getItem(TOKEN_KEY);
            const response = await fetch("/chat/encrypt-message/", {
                method: "POST",
                headers: {
                    "Authorization": "Token " + token,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    message: message,
                    aes_key: savedAESKey
                })
            });
            const data = await response.json();

            hideLoading(); // ·∫®n loading khi nh·∫≠n ph·∫£n h·ªìi

            if (data.encrypted_message) {
                const payload = {
                    message: `${currentUsername}: [ENCRYPTED] ${data.encrypted_message}`,
                    username: currentUsername
                };
                socket.send(JSON.stringify(payload));
                messageInput.value = "";
                showToast("‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn m√£ h√≥a!", "success");
            } else {
                showToast("‚ùå " + data.error, "error");
            }
        } catch (error) {
            hideLoading(); // ·∫®n loading n·∫øu c√≥ l·ªói
            showToast("‚ùå L·ªói k·∫øt n·ªëi!", "error");
        }
      }

        // H√†m gi·∫£i m√£ tin nh·∫Øn
        async function decryptMessage(encryptedMessage) {
          const token = localStorage.getItem(TOKEN_KEY);
          try {
              const response = await fetch("/chat/decrypt-message/", {
                  method: "POST",
                  headers: {
                      "Authorization": "Token " + token,
                      "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                      encrypted_message: encryptedMessage,
                      aes_key: savedAESKey
                  })
              });
              const data = await response.json();

              if (data.decrypted_message) {
                  return data.decrypted_message;
              } else {
                  return `[ENCRYPTED] ${encryptedMessage} (Kh√¥ng th·ªÉ gi·∫£i m√£)`;
              }
          } catch (error) {
              return `[ENCRYPTED] ${encryptedMessage} (L·ªói k·∫øt n·ªëi)`;
          }
        }
        // H√†m hi·ªÉn th·ªã/·∫©n loading
        function showLoading() {
          const loadingOverlay = document.getElementById("loadingOverlay");
          loadingOverlay.classList.remove("d-none");
        }

        function hideLoading() {
          const loadingOverlay = document.getElementById("loadingOverlay");
          loadingOverlay.classList.add("d-none");
        }

        function saveAESKey() {
          const aesKey = document.getElementById("aesKeyInput").value.trim();
          const aesKeyStatus = document.getElementById("aesKeyStatus");
          
          if (aesKey) {
              savedAESKey = aesKey;
              aesKeyStatus.textContent = "C√≥ key m√£ AES";
              aesKeyStatus.className = "text-success small mt-1";
              showToast("‚úÖ ƒê√£ l∆∞u kh√≥a AES!", "success");
          } else {
              savedAESKey = null;
              aesKeyStatus.textContent = "Kh√¥ng c√≥ key m√£ AES";
              aesKeyStatus.className = "text-muted small mt-1";
              showToast("‚ùå Vui l√≤ng nh·∫≠p kh√≥a AES tr∆∞·ªõc khi l∆∞u!", "error");
          }
        }

        checkLoginStatus();
    </script>
    {% comment %} <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'929839e9cbfc539b',t:'MTc0MzUxMTk2OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script> {% endcomment %}
</body>
</html>